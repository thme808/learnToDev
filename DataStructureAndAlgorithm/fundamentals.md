# 자료구조와 알고리즘의 기본 
## 자료구조와 알고리즘 공부의 필요성
자료구조나 알고리즘을 깊게 혹은 얕게라도 공부하지 않아도 개발로 밥벌어 먹고 사는데는 문제가 없다. 실제로 꽤나 오래 현업에 몸 담근 자칭 개발자라는 족속들이 (나를 포함하여) 자료구조나 알고리즘 따위를 자격증이나 코딩 테스트, 취업용도로 받아들이고 있는 현실이다. 갓생사는 신입이나 학부생들이 코딩은 더 잘한다, 나도 저런 시절이 있었지하는 말로 웃으며 위안 삼지만... 과연 그 외에 다른 부분에서라도 그들보다 뛰어날까?

스스로 다 안다고 생각될 때가 가장 위험하다. 시간은 누구에게나 동등하게 흐르고 그 물길 따라 흘러간 곳은 결국 내 선택들이 켜켜이 쌓여 만든 섬이다. 

결국 공부라는 것은 하나의 길에서 만나는데, 더 많은 것을 알수록 더 많은 해결책을 제시할 수 있다. 알고리즘적 사고는 이 해결책을 다양한 방법으로, 더 간결하게, 혹은 더 우아한 방식으로 제시한다. 데이터 구조와 알고리즘은 프로그래밍 언어에 비종속으로 공부할 수 있다는 장점이 있다. (물론 어떤 프로그래밍 언어에서 지원하는 데이터 구조가 다른 프로그래밍 언어에서 지원하지 않는 경우도 있다) 결국 데이터 구조와 알고리즘을 공부한다는 것은 선대 개발자들의 브레인스토밍 결과를 떠먹고, 내가 가진 현재의 문제 해결에 적용하는 데 의의가 있다.

## 데이터 구조와 알고리즘의 관계
데이터 구조는 알고리즘을 덜 복잡하게 만든다. 

### 컴퓨터 메모리 구조
데이터 구조와 컴퓨터 메모리는 밀접한 관련이 있다. 데이터 구조는 사용 가능한 자원을 효과적으로 관리하기 위해 고안되었는데, 이 자원이 바로 컴퓨터 메모리이기 때문이다.

메모리는 계층적으로 구성되어있고 각 층 마다 정해진 역할이 있다.

**컴퓨터 메모리 계층 구조**
-- 레지스터
--- 캐시(L1, L2)
---- 메인 메모리 (RAM)
----- 하드 디스크 (HDD,SSD)

엑셀 프로그램의 실행을 예를 들어보자. 디스크에 설치된 엑셀은 실행 시 RAM으로 적재된다. 캐시의 경우 L1, L2 캐시가 대표적이며, L1캐시는 레지스터 만큼 빠르고 용량도 작다. (수십 KiB ~ 100KiB) 반면에 L2캐시는 메모리보다는 빠르고 수백KiB 정도의 용량을 가진다. 눈치챘겠지만, 캐시는 용량이 적을 수록 빠르다. 용량이 작기 때문에 캐시메모리 내에서 데이터를 더 빠르게 찾을 수 있기때문이다.
- KiB: 킬로바이너리바이트, 키비바이트

최상단의 레지스트리는 가장 빠른 연산속도를 가지고있다. 저급 프로그래밍 언어를 이용하면 레지스트리 단에도 직접 접근이 가능하다.

### 가상 메모리
메모리 주소는 RAM이나 하드디스크 같이 실제 프로그램이 저장되거나 적재되는 물리적 공간을 말한다. 하지만 물리적 메모리 공간은 한정적이기 때문에 부하가 큰 프로그램 실행시 자원이 고갈될 수도 있다. 이 때 운영체제는 가상 메모리 기술을 이용해 프로그램 실행에 충분한 메모리를 확보한다. 가상 메모리 기술이란, 운영체제는 물리적 주소인 메모리 주소에 가상의 주소를 매핑하여 실제보다 많은 메모리가 있는 것처럼 프로그램을 속이는 것이다. 

### 페이징과 페이지 테이블
가상 메모리는 물리적 메모리 공간에 매핑되어 있고 가상 메모리 주소로 메모리상 위치를 식별할 수 있다. 가상 메모리는 일정한 크기의 페이지로 나누어 메모리 공간에 분할되어 저장된다. 이를 다시 안전하게 하나로 불러오기 위해서 페이지 테이블을 참조하여 각 페이지에 매핑된 주소를 찾는다.

데이터는 연속된 공간이 아니라 드래곤볼 마냥 흩어져 저장되고 페이지 테이블을 참조해 각 페이지의 물리 주소를 찾아 온전한 모습으로 불러온다.
- 페이징: 가상 메모리를 일정한 크기의 페이지로 나누는 것
- 페이지 테이블: 가상주소(페이지에 매핑된 주소)를 메모리주소(물리적주소)로 변환하는 개념

## 기본자료형
### boolean, 0과 1
boolean 자료형은 0과 1, 참과 거짓 등 두 가지 상태를 표현하는 논리 자료형이다.
컴퓨터는 수많은 트랜지스터로 구성된 프로세서를 핵심으로 기동된다. 이 트랜지스터는 크고 끔(on & off)으로써 각각이 0 혹은 1의 값을 나타낸다. 프로세서는 수많은 트랜지스터의 이진데이터 표현으로 아주 복잡한 연산을 이진수로 수행한다.

양자 컴퓨팅에서는 양자비트인 qubit (quantum bit) 이 0과 1을 대신한다. 그러나, 전통적인 컴퓨팅 분야에서 0과 1이 명백한 켜기과 명백한 끄기 상태를 표현하는 것과 달리 양자 컴퓨팅 분야에서는 0과 1 어느 쪽으로도 확정할 수 없는 상태인 큐비트가 표준이다.

### 정수와 부동 소수점(floating point)
정수는 양의 자연수, 음의 자연수, 0 을 말한다.

부동 소수점이란 점(.)의 위치가 숫자를 정밀하게 표현하기 위해 어딘가에 떠다닌다 하여 floating point(부동점, 떠다니는 점) 라고 한다. 

부동 소수점 수는 정수와 마찬가지로 실제 수만큼 정밀하게 표현하는데에는 컴퓨팅에 한계가 있다. 그래서 정밀도에 따라 자료형을 나누는데, **단정도(single precision)와 배정도(double precision)** 있다. Windows OS를 설치할 때 32/64bit 옵션이 있는데, 이때 32bit 윈도우의 1워드는 32bit, 64bit 윈도우의 1워드는 64bit이다.
단정도 부동소수점 수는 1워드를 표현할 때 32bit를, 배정도 부동소수점 수는 64bit를 사용한다. 그래서 단정도 부동소수점 수는 float, 배정도 부동소수점 수는 double 자료형을 사용한다.

## 함수, 메서드, 프로시져
수학에서의 함수는 정의역을 치역에 대응 시키는 표현식이다. 정의역의 각 원소는 반드시 치역 내 하나의 원소에 대응한다. 인풋이 있고 아웃풋이 있어야한다. 반면에 프로그래밍에서 함수는 단순히 동작을 수행하는 코드 집합이며, 프로그램 내의 작은 프로그램 단위다. 인풋이 있을 수도 없을 수도 있으며, 아웃풋도 있을 수도 없을 수도 있다.

plsql같은 절차형 프로그래밍언어에서는 프로시져와 함수를 반환값의 유무로 구분하기도한다. 함수는 반환값을 가지는 반면에 프로시져는 반환값이 없다.

메서드도 결국 함수다. 객체 지향 프로그래밍언어에서는 어떤 사물, 개념등을 객체화하여 클래스라 불리는 청사진을 만든다. 이 클래스 내부에 있는 함수를 메서드라고 부른다. 그래서 메서드는 항상 객체이름을 통해서 호출하는 함수다.

## 반복과 재귀
재귀는 자기 자신을 끊임 없이 호출한다. 반복과 혼동 될 수 있지만, 재귀는 자기 자신을 반복해서 호출한다는 점이 다르다. 컴퓨터 메모리에는 한계가 있으므로 특정 조건을 만족하면 재귀를 빠져나간다는 탈출 조건을 분명히 해야한다. 자기 자신을 호출할  수 있는 최대 횟수는 한계를 `최대 재귀 깊이`(maximum recursion depth) 라고하는데, 이를 초과하면 그 유명한 `스택 오버플로우` 에러가 발생한다.

재귀냐 반복이냐를 선택하는 것은 개발자의 재량이다.

## 알고리즘 분석: 시간복잡도, 공간복잡도
알고리즘을 설계한 후 이 알고리즘이 얼마나 효율적으로 수행되는에 대한 판단이 필요하다. 이 때 시간복잡도와 공간복잡도를 이용해 알고리즘의 효율성을 분석할 수 있다.

- **시간복잡도**: 알고리즘 수행 시간을 분석하여 효율도를 나타낸다. 가장 일반적으로 사용하는 방식.
- **공간복잡도**: 공간이란 알고리즘이 수행될 때 점유하는 컴퓨터 메모리 공간을 뜻한다. 공간복잡도는 자원이 제한된 시스템에서 알고리즘의 성능을 측정할 때 유용하다.

### 빅 오 표기법 (Big O Notation)
- O(1): 상수형 알고리즘, 데이터 입력량과 무관하게 실행 시간이 일정하다.
- O(n): 선형 알고리즘, 데이터 입력량에 비례하여 실행 시간이 늘어난다.
- O(logn): 로그형 알고리즘, 시간이 선형적으로 증가하면 n이 기하급수적으로 늘어난다. 즉, 데이터 입력량이 늘어날수록 단위 입력당 실행 시간이 줄어든다.
- O(nlogn): 선형-로그형 알고리즘, 데이터 입력량이 n배 늘어나면 실행시간이 n배 조금넘게 늘어난다. nlogn배.
- O(n**2): 2차 알고리즘, 데이터 입력량의 제곱에 비례하여 실행 시간이 늘어난다. 
- O(2**n): 지수형 알고리즘, 데이터 입력이 추가될 때마다 실행 시간이 2배 늘어난다.
- O(n!): 계승형 알고리즘, 데이터 입력이 추가될 때마다 실행 시간이 n배 늘어난다.

성능이 좋은 순서대로 나열하면 아래와 같다.
> O(1) > O(logn) > O(n) > O(nlogn) > O(n**2) > O(2**n) > O(n!)

## 선형 데이터 구조
배열과 리스트는 대표적인 선형 데이터 구조이고 누구에게나 쉽게 와닿는 데이터 구조다. 선형 데이터 구조에서 이들이 가장 핵심적인 이유는 다른 데이터 구조의 기반이 된다는 점이다. 다른 선형 데이터 구조를 구현할 때 배열과 리스트를 사용한다.
**배열**
배열은 같은 자료형의 요소를 저장하며, 연속적으로 정렬되어 있다. 그래서 인덱스 값으로 특정 위치의 배열 요소에 즉시 접근할 수 있다. 그런데 이러한 특징 때문에 데이터를 배열 중간에 새로 추가하거나 삭제할 때 인덱스 값을 전체 새로 지정해줘야 하는 불편이 있다. 당연하게도 배열 요소가 많아 질수록 빈번한 삭제/삽입은 많은 시간이 소요된다. 이것이 배열의 주요한 한계점이다.

배열은 연속적으로 데이터를 저장하기 때문에 배열의 크기를 지정하고 그 만큼의 메모리 공간을 우선 할당해야한다. (일부 프로그래밍 언어에서...)

**리스트**
리스트는 배열의 다른 유형이다. 배열과는 다르게 요소를 메모리 상에 흩어져 저장한다. 그러기 위해서는 각 요소는 데이터 요소와 포인터(참조, 주소)로 구성된다. 포인터는 바로 다음 요소의 메모리상 위치를 가리킨다.
- 연결 리스트에서는 데이터 요소와 포인터(참조, 주소)의 쌍을 노드라고 부른다.
- 단방향 연결 리스트는 노드가 하나가 포인터를 하나만 가지고 있고, 마지막 노드의 포인터는 null을 가르켜 마지막 요소임을 표시한다.
- 양방향 연결 리스트는 노드가 양쪽으로 2개의 포인터를 가지고 있어서 좌우로 쉽게 이동이 가능하다. 양방향 연결리스트는 데이터를 삭제, 양방향으로 순회할 때 효율적이다.
- 순환 연결 리스트는 마지막 노드가 null이 아닌 첫번째 노드를 가르킨다. (ring 형태) 컴퓨팅 분야에서 버퍼링과 관련된 용도로 많이 사용된다.

**스택**
스택은 후입선출 데이터 구조로 가장 최근에 입력된 데이터가 가장 앞 주소에 배치된다. 스택은 사용 기술이나 요구사항에 따라 다양한 방식으로 구현되어 사용된다. 스택이라는 자료형을 프로그램언어에서 제공하는 것이아니라 리스트나 배열 등의 자료형을 이용해 스택구조로 구현한다.
- push & pop: 이름그대로 push는 데이터를 가장 앞주소에 밀어넣고, pop은 가장 마지막 추가된 요소를 삭제한다.

재미있게도 스택은 스택의 최상단 데이터에만 접근이 가능하다. 맨 처음 넣은 데이터에 접근하기 위해서는 순서대로 쭉 삭제하면서 나아가야한다. 그러니 검색 속도가 느리다. 스택이 유용하게 쓰이는 경우는 역추적이 필요한 케이스다. 문자열을 반전시키는 것이 그 좋은 예다.

스택은 생성 방식에 따라 고정 스택과 실행중에 크기와 메모리를 늘릴 수 있는 동적 스택으로 나눈다. 정적 스택은 배열을, 동적 스택은 단방향 연결 리스트를 이용해 설계할 수 있다. 스택은 함수 호출, 스케쥴링, 인터럽트 메커니즘 등의 컴퓨팅 프로세스에서 활용되고 있다.

**큐**
큐는 각 요소에 우선순위를 부요하는 데이터 구조다. 큐는 스태과는 반대로 신규 데이터를 가장 뒷 쪽에 배치한다. 그래서 먼저 추가된 요소가 우선적으로 삭제되는 선입선출 형태다. (먼저 추가된 요소가 우선순위가 높음) 큐는 비선형 데이터 구조도 있다. 

우선순위 큐는 큐를 확장한 것으로 key, value를 사용해 큐 요소를 정리한다. 즉 우선순위가 key, value에 따라 결정될 수 있다. 요소의 우선순위를 비교해 우선순위가 높으면 먼저 삭제, 같다면 먼저 추가된 요소를 삭제한다. 

우선순위 큐는 데이터 압축, 네트워킹 등 컴퓨터 과학 분야에서 널리 사용된다.

## 트리 데이터 구조
루트노드: 최상단 노드
부모노드: 여러 자식 노드를 가짐
자식노드: 하나의 부모노드를 가짐 (그래프 자료구조는 여러 부모노드를 가짐)
말단노드: 리프노드라고도 하며 더 이상 자식노드를 갖지 않는 노드
에지(edge); 노드를 연결하는 선
서브트리: 노드 하나와 그 자식 노드들 (트리의 부분)

**이진 트리**
부모 노드가 항상 2개 이하의 자식 노드와 연결되어 있는 트리.
**이진 탐색 트리(BST)**
이진 탐색 트리는 **노드의 키를 기준으로 정렬된 상태**다. 이진 탐색 트리에서의 주요동작은 노드 추가, 삭제, 탐색, 그리고 키가 존재하는지 확인이다. 

**BST 특징**
	- 모든 노드는 서로 다른 유일한 키값을 가진다.
	- 왼쪽 서브 트리의 키는 노드의 키보다 작다.
	- 오른쪽 서브 트리의 키는 노드의 키보다 크다.

> 이진 탐색 트리는 정렬된 데이터를 약속된 기준으로 정렬하기 때문에 키 탐색이 빠르다. 정렬된 데이터를 저장하는데 유용하다.

[image:F761B048-3F5F-4DFF-8FEF-FB9FB042070B-423-000004FDE6A90F5E/EFA37019-7FD6-4362-AC19-3BCDEA5096BE.png]

**AVL 트리 (균형 이진 트리)**
불균형 이진 트리의 일반적인 구조는 대부분의 노드가 하나의 자식노드를 가지는 경우다.  편향 이진 트리(skewed binary search tree) 라고 부르며 오른쪽, 왼쪽으로 편향될 수 있다. 
[image:0B776C12-79FC-43EF-BE92-2F06DC803174-423-000005033E23D225/AD496923-44E5-4FED-AE0A-0CA628BA2A44.png]
> 편향 이진 트리의 문제는 이진 트리로써의 장점이 없어진다는 것. 많은 부모 노드가 자식 노드를 하나만 가진 다는 것은 이진 트리의 전체, 혹은 일부 서브트리가 리스트같은 구조가 된다. 트리의 높이가 높아지면 검색의 성능이 떨어지는 것은 당연. 편향 이진 트리를 만나면 최악의 경우 키 탐색에 모든 노드를 순회해야 하기 때문에 worst-case 시간 복잡도가 O(n)이다. 

AVL이진 트리는 양쪽 서브트리가 **절댓값 2 이상 높이 차이**를 감지하면 트리 회전을 수행하여 트리의 균형을 조정한다. 이 높이 차이를 균형 인수(Balanced Factor)라고 하며 높이 차이가 절댓값 2 이상이면 트리를 리밸런싱한다. 
*균형인수 = 왼쪽 서브트리의 높이 - 오른쪽 서브트리의 높이*

**AVL트리 불균형 상태 4가지**
- LL상태: Left-left 상태로 자식노드가 왼쪽으로 연이어 이어진 상태. 균형인수가 +2인 상태. LL회전하여 불균형 해소.
- RR상태: Right-right 상태, 균형인수가 -2, RR회전하여 불균형 해소
- LR상태: Left-right 상태, 균형인수가 +2, LR회전하여 불균형 해소
- RL상태: Right-left 상태, 균형인수가 -2, RL회전하여 불균형 해소

이렇게 트리의 균형을 조정하는 트리를 균형 이진 트리라고 하며, AVL트리 외에도 레드 블랙트리 등이 있다. 
자체적으로 균형을 조정하는데에도 눈에 보이지 않는 비용이 드는데, AVL트리의 시간 복잡도는 O(logn) 이다.

**Red-black 트리**
레드블랙 트리는 트리의 구조 때문에 리밸런싱 과정에서 트리 회전수가 적어 AVL트리보다 효율적이다. 시간 복잡도는 O(logn).
레드블랙 트리는 노드마다 빨강 또는 검정으로 해석되는 비트를 포함하는 특징이있다.

**B 트리**
B 트리는 자식 노드를 3개 이상 갖는 부모노드가 있다. 파일 시스템이 B 트리가 적용되는 대표적인 예로, 폴더 내에 각각 여러 파일이 든 다른 폴더가 존재하는 모습을 상상해보자.

**힙**
> 힙 메모리와 무관 주의
힙은 이진 트리 데이터 구조의 한 종류로, 값이 최대 혹은 최소인 노드에 빠르게 접근하는 경우 유용하다. 힙의 구조에는 최대힙, 최소힙이 있다. 
- 최대힙: 루트노드가 힙에서 가장 큰 값
- 최소힙: 루트노드가 힙에서 가장 작은 값

## 해시 데이터 구조
💡해시란 하나의 값을 다른 값으로 변환하는 것. 
- 변환된 값은 원래 값으로 역추적이 불가하여 단방향 암호화로 볼 수 있다. 
- 입력 데이터의 길이와 타입에 관계없이 해시값의 길이는 고정된다.
- 낮은확률로 하나의 정의역이 2개의 치역에 대응될 수 있으며 이를 해시충돌이라 한다. (호랑이 -> 123!@, 고양이 -> 123!@)

### 해시 테이블
해시 테이블은 키와 값으로 구성된 검색 시스템이다. 
💡 해시맵과 다른점은?
- java에서 해시테이블은은 Java Collection Framework 가장 오랜된 멤버 중 하나이며, 수학적 해시테이블을 데이터 구조로 구현한 것. Hashmap, Hashtable은 구조적으로 동일함. Hashtable은 동기화가되는 반면, Hashmap은 동기화되지 않는다는 중요한 차이점이 있음.
- 모든 초기 컬렉션과 마찬가지로 동기화되며, 이는 심각한 성능 문제를 초래함.
- 그래서 HashMap이 Hashtable의 대체품으로 등장함. (Hashtable은 이제는 거의 사용하지않음)
- Hashtable은 Dictionary 클래스를 상속하고 HashMap은 AbstractMap 클래스를 상속
- HashMap은 하나의 null 키와 여러 개의 null 값을 허용

키를 기준으로 해시 테이블을 검색하면 대응하는 값을 찾을 수 있기에,  검색 시간복잡도는 O(1)이다.  키를 입력하면 해시 함수에 입력되어 배열의 인덱스에 매핑된 해시값이 생성된다.
[image:2F7DB020-3F84-44F3-83D9-5520A426A49F-423-0000051E26F70388/FCB0F9CD-28AD-490C-A4CE-838D1F3B3D22.png]
