# 자료구조와 알고리즘의 기본 
## 자료구조와 알고리즘 공부의 필요성
자료구조나 알고리즘을 깊게 혹은 얕게라도 공부하지 않아도 개발로 밥벌어 먹고 사는데는 문제가 없다. 실제로 꽤나 오래 현업에 몸 담근 자칭 개발자라는 족속들이 (나를 포함하여) 자료구조나 알고리즘 따위를 자격증이나 코딩 테스트, 취업용도로 받아들이고 있는 현실이다. 갓생사는 신입이나 학부생들이 코딩은 더 잘한다, 나도 저런 시절이 있었지하는 말로 웃으며 위안 삼지만... 과연 그 외에 다른 부분에서라도 그들보다 뛰어날까?

스스로 다 안다고 생각될 때가 가장 위험하다. 시간은 누구에게나 동등하게 흐르고 그 물길 따라 흘러간 곳은 결국 내 선택들이 켜켜이 쌓여 만든 섬이다. 

결국 공부라는 것은 하나의 길에서 만나는데, 더 많은 것을 알수록 더 많은 해결책을 제시할 수 있다. 알고리즘적 사고는 이 해결책을 다양한 방법으로, 더 간결하게, 혹은 더 우아한 방식으로 제시한다. 데이터 구조와 알고리즘은 프로그래밍 언어에 비종속으로 공부할 수 있다는 장점이 있다. (물론 어떤 프로그래밍 언어에서 지원하는 데이터 구조가 다른 프로그래밍 언어에서 지원하지 않는 경우도 있다) 결국 데이터 구조와 알고리즘을 공부한다는 것은 선대 개발자들의 브레인스토밍 결과를 떠먹고, 내가 가진 현재의 문제 해결에 적용하는 데 의의가 있다.

## 데이터 구조와 알고리즘의 관계
데이터 구조는 알고리즘을 덜 복잡하게 만든다. 

## 기본자료형
### boolean, 0과 1
boolean 자료형은 0과 1, 참과 거짓 등 두 가지 상태를 표현하는 논리 자료형이다.
컴퓨터는 수많은 트랜지스터로 구성된 프로세서를 핵심으로 기동된다. 이 트랜지스터는 크고 끔(on & off)으로써 각각이 0 혹은 1의 값을 나타낸다. 프로세서는 수많은 트랜지스터의 이진데이터 표현으로 아주 복잡한 연산을 이진수로 수행한다.

양자 컴퓨팅에서는 양자비트인 qubit (quantum bit) 이 0과 1을 대신한다. 그러나, 전통적인 컴퓨팅 분야에서 0과 1이 명백한 켜기과 명백한 끄기 상태를 표현하는 것과 달리 양자 컴퓨팅 분야에서는 0과 1 어느 쪽으로도 확정할 수 없는 상태인 큐비트가 표준이다.

### 정수와 부동 소수점(floating point)
정수는 양의 자연수, 음의 자연수, 0 을 말한다.

부동 소수점이란 점(.)의 위치가 숫자를 정밀하게 표현하기 위해 어딘가에 떠다닌다 하여 floating point(부동점, 떠다니는 점) 라고 한다. 

부동 소수점 수는 정수와 마찬가지로 실제 수만큼 정밀하게 표현하는데에는 컴퓨팅에 한계가 있다. 그래서 정밀도에 따라 자료형을 나누는데, **단정도(single precision)와 배정도(double precision)** 있다. Windows OS를 설치할 때 32/64bit 옵션이 있는데, 이때 32bit 윈도우의 1워드는 32bit, 64bit 윈도우의 1워드는 64bit이다.
단정도 부동소수점 수는 1워드를 표현할 때 32bit를, 배정도 부동소수점 수는 64bit를 사용한다. 그래서 단정도 부동소수점 수는 float, 배정도 부동소수점 수는 double 자료형을 사용한다.

## 함수, 메서드, 프로시져
수학에서의 함수는 정의역을 치역에 대응 시키는 표현식이다. 정의역의 각 원소는 반드시 치역 내 하나의 원소에 대응한다. 인풋이 있고 아웃풋이 있어야한다. 반면에 프로그래밍에서 함수는 단순히 동작을 수행하는 코드 집합이며, 프로그램 내의 작은 프로그램 단위다. 인풋이 있을 수도 없을 수도 있으며, 아웃풋도 있을 수도 없을 수도 있다.

plsql같은 절차형 프로그래밍언어에서는 프로시져와 함수를 반환값의 유무로 구분하기도한다. 함수는 반환값을 가지는 반면에 프로시져는 반환값이 없다.

메서드도 결국 함수다. 객체 지향 프로그래밍언어에서는 어떤 사물, 개념등을 객체화하여 클래스라 불리는 청사진을 만든다. 이 클래스 내부에 있는 함수를 메서드라고 부른다. 그래서 메서드는 항상 객체이름을 통해서 호출하는 함수다.

## 반복과 재귀
재귀는 자기 자신을 끊임 없이 호출한다. 반복과 혼동 될 수 있지만, 재귀는 자기 자신을 반복해서 호출한다는 점이 다르다. 컴퓨터 메모리에는 한계가 있으므로 특정 조건을 만족하면 재귀를 빠져나간다는 탈출 조건을 분명히 해야한다. 자기 자신을 호출할  수 있는 최대 횟수는 한계를 `최대 재귀 깊이`(maximum recursion depth) 라고하는데, 이를 초과하면 그 유명한 `스택 오버플로우` 에러가 발생한다.

재귀냐 반복이냐를 선택하는 것은 개발자의 재량이다.